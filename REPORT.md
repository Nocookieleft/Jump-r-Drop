Report on Project Jump or Drop  
---------------------------------
by Anna Dechering
10288384

###The Game 

The game features a small bunny that needs to hop onto platforms to vertically cross the screen and get to a carrot, while trying not to fall off the platforms. Should the bunny fall down off the screen, the game is over and the player has lost. If the bunny reaches the carrot, the player has won and the game is over as well. The player can make the bunny jump by touching the screen (even make double-jumps) to try and get onto the platforms. The bunny automatically moves horizontally on the screen, thus the player must time its jumps quite accurately. 


***

Technical Design
-----------------

The application starts with the GameViewController rendering a scene of which the class is defined in GameScene.swift. As the didMoveToView function is overridden, the scene will load in an avatar of the Player class, a platform generator of the PlatformGenerator class, a moving backdrop of the class Moving Level, a pause button in the upper right corner of the screen and a label with the message "Tap to Start Game" in the high center of the screen. 

***Platform Generator***
The platform generator will populate the screen (as high as twice the screen's height) with platforms from the Platform Class and will always draw a 'platformGround' that spans the width of the screen at the bottom of the scene to let the player have a platform to begin from. The other platforms are placed in a somewhat random position and added to an array of platforms to register their amount (this array was used to iterate the amount of platforms generated stop or start the generator according to it... the functionality of this array is somewhat suspended in this version). The platforms are spritenodes added to an invisible backgroundTestNode to work with the same coordinate system and to enable the control on all their actions (through iteration of the children nodes of the backgroundTestNode). The scene is populated by repeatedly adding a platform with a fixed size on a random position along the x-axis, then adding another smaller platform (half the size of the other platform) on the left or right side of the screen (according to the position of the bigger platform). The next platform the generator makes (supposedly) checks if the random position of the former platform is equal to the random position he wants to give to the platform he still needs to place. If the positions are the same or if the former position + the platform's width is crossing the position of the newly made platform, the generator will try to adjust the position of the newly made platform as not to place the platforms exactly above eachother. This was done to prevent the generator populating the scene with a stack of platforms positioned on top of each other so the player has no way of climbing them. The platform generator will furthermore load in a 'finishline' in the form of a spritenode (now an image of a carrot) that registers if the player makes contact with it. 

The scene will furthermore load in some invisible tresholds like the upperTreshold, lowerTreshold and the rockBottom. 
All the handeling of the contact (by comparing contactbitmasks) is done in the GameScene. Contact will be registered mainly about the contact of the avatar with sprites of other categories like the platforms, tresholds, rockbottom and finishline. As such the player will be able to rest on a platform when in contact and will lose or win the game if it hits respectively the rockbottom or the finishline: The rockBottom treshold is positioned a little lower than the edge of the screen. If the avatar would drop down and cross this treshold, the game is over and the player has lost the game. 
On the other hand, if the avatar would come in contact with the finishline (from the platform generator) the game would end as well, but this time the player would have won the game (as he has finished climbing all the platforms). 

Over the height of the screen two other tresholds are placed: the upperTreshold and the lowerTreshold. The upperTreshold is set around the middle of the screen's height and if the player should cross this treshold, all the platforms on the screen will start moving down the screen. As the platforms move down, the player is forced to move the avatar up on the platforms (to avoid hitting the rockBottom) and this will result in the animation of the bunny climbing the platforms.  
If the avatar hits the lower treshold, the platforms stop moving. This way the player has more of a chance to continue the game.

There is only one other contact registered and this is when a platform hits rockbottom. The platform will then be removed from the array of platforms that keeps track of the amount of platforms in play.

The game mainly focuses on the touch event when the user touches the screen. The game starts at the first touch and the only interaction the user can give is by touch. There are two modes of the gamescene when the game has started: paused or not paused. When the player touches a sprite with a kind of pause-symbol at the upper right corner, the game is set to a paused state. A shapenode will appear to simulate a menu with the message that the game is paused and twho nodes that represent buttons to invite the user to touch either of them. These buttons are labeled "Resume" and "Restart" and will either let the user continue the game or render a new scene like the GameScene to start another game. 
To make this work, the scene registers not only the touch of the user, but also registers if the user touches a specific node. The default functionality is set to let the avatar jump (once the game has started). The other functionality looks for the name of the node and reacts on the name of the pause button. In the paused mode the touch on the buttons and labels within the simulated menu are registered to these other functions. 


***

Important changes
------------------

####The platform generator
The platform generator class is probably the class which has changed the most over the process of the whole project. The problems with this class were foreseen, but not thought out rigorously. The platform generator had to generate platforms continously along the height of the screen as the player would jump upwards and cross the height of the screen. First this was done by implementing the generate platform function. This function would be called whenever the player would hit the upper treshold and would add a platform somewhere high off-screen that would continue to move down. This resulted in two problems: the coordination of the platform was hard to get right (it would not suffice to add the platform at twice the height of the screen as off-screen there could be platforms positioned ...or none even close) and the generation of the platforms did not happen at the right time (as the avatar could move not only from down up through the treshold, but also from up going down through the treshold or even stay above the treshold, resulting in no further generation at all). Another way of going about this was to call upon the generateplatform function with a timer function that called upon itself after waiting for a couple of seconds. However this was not accurate at all as it didn't compare distances but time (which proved hard to work with as it would have to stop by invalidating timers).


####The other platform generator 
After struggling a lot with the generation and placement of platforms, we decided to try another approach to the whole way these platforms were generated. To this end the otherPlatformgenerator was brought into life. This function needed to generate a platform of a random width beginning and positioning itself at the left edge of the screen. It would then create a gap represented by an invisible (for testing and debugging colored white) bar of a fixed size. This gap would then be followed up by another platform of a size that would span the distance from the gap to the other right edge of the screen. This way the platform-gap-platform sequence could bring control of the way the platforms might be positioned. If this would render nicely, the values could be changed afterwards to make the first and last platform seem more floating from the sides of the screen and this way their position along the x-axis could be controlled. The gap would have a fixed width that could be used to let the avatar move through and always let is have a chance of getting from one platform to another. The platforms could be rendered in sequence more easily at a fixed distance, but seeming more random in their position as well. 
Some problems occurred like the movement of the platforms leaving the gaps behind on the screen, but they were quickly fixed.
However, problems occured as the otherPlatformgenerator had to relate to the coordinatesystem of the backgroundTestNode. Somehow we failed to get these coordinates right and the generation proved not as controlled as once thought. After a while both the generatePlatform and the otherPLatformgenerator were thrown away, as well as a function that checked how many platforms were on the screen or in the array to platforms. Because time was running out, the decision was made to add a finishline and let the general population be done running higer than the scene's actual size height to at least have a bit of the scrolling effect in the game. To improve a little more on the scrolling effect of the level, the player's y position was tracked in a function called "setSpeed" to try and move the platforms more quickly down the screen if the avatar remains on the upper side of the screen and to slow movement down as the avatar is on the lower side of the screen. 


####The movement of the avatar
The movement of the avatar has also changed considerably. The way it had to move horizontally and have a kind of jumping animation was hard because it had to abide the rules of the spritekit that was used. 

***Turning and Flipping*** In the first week the avatar was not moving at all as expected, as working with SKActions on SpriteNodes was something completely new to me. To have some visual feedback, the avatar was constraint on the screen by toggeling its movement (moving right or left). This way we could work on the jumping motion of the avatar. In the second week the avatar's movement left and right was improved by the help of the waitForDuration action and figuring out the screen didn't automatically see the boundaries of the screen as positioned in portrait mode (now the GameViewController restricts the user from flipping the screen to a landscape mode). To improve on the way the avatar seemed to be floating left and right over the screen (while just facing right), we decided to flip the image as it hits the edges of the screen. This called for a translation in the way the sprite would move, as it would draw the sprite in negative values if the image was flipped (and think it was outside the bounds of the screen). Drawing the image of the sprite still looks very silly, but it looks better than letting the avatar float from on side to the other. However, with the translation of the movement along the x-axis of the scene, implementing a movement for the avatar alongthe y-axis at the same time became a bit more difficult and confusing. 

***Jumping vs Gravity*** The jumping animation was set in the first weeks to move the player up vertically as the player touched the screen and slow its movement down when the player's touch was not registered anymore. Along with a continuous simulated gravity, the jumping animation looked quite well. Jumpin onto a platform seemed to work by resetting the baseline of the avatar as it would come in contact with a platform. However, we couldn't find a way to register when the avatar was no longer ON the platform, only when it was no longer crossing the platform. This made it difficult to set the velocity of the upwards-movement of the avatar or enforce the simulated gravity as the player would fall off the platform. This way, the avatar could jump onto a platform but would stay suspended in mid-air as he would move left or right. 
Therefore we looked more into the functions Apple provided us with the SpriteKit and came upon the SKPhysicsBody class. This class lets you simulate physics and thus forces like gravity in your game. It was used to give categories to the sprites (by using bitmasks) and flag if one category was crossing their fields with another. However, it also had a boolean that set "affectedToGravity" to true or false. Setting this to true for the player class and to false for the platforms resulted in the avatar being able to stay onto a platform but fall off of them as well (if they dissapeared). However, using the gravity of the physicsbody resulted in problems for the jumping animation. The function that animated the jump could not be used anymore as it struggled against the gravitational forces. Therefore we looked at the physicbody for a resolution and came upon a way to 'apply an impulse' to the avatar's y position. This application of an impulse as the player touches the screen was rendered in newton seconds (not quite sure what that means, but that is what the documentation says), which resulted in the difficulty of controlling the impulse or the registration of the y position or velocity (as it was unclear where in the functions the dynamic could be caught). At the end, the gravitational forces were the most important for the game dynamic (falling down from the platforms as well as the edge of the screen) and the impulse stayed along with the physicsbody's gravity.

***Flying or Grounding*** Some of the pains that were gone through were caused by the physicsbody class. As the physicsbody seems to provide out-of-the-box ready attributes, these attributes work or correspond to (your already worked out) functions was sometimes frustrating. In example the physicsBody?.resting function supposedly would check if a spritenode was resting on another spritenode. However, it didn't work that well for checking if the avatar was resting on a platform or not. You could only check if the resting boolean was not nil (instead of true or fale) which made the bunny look like it was flying if the user repeatedly touched the screen. At that moment, a thought to change the game entirely came to mind (by making the platform have spikes around the edges, making the bunny a bird and let the user try and get to the top without making the bird into sate), but thinking of the time-frame this idea was quickly set aside. In stead, we stuck with the former isGrounded boolean and let the bunny more or less stick to the platforms.

In aftermath the other idea would not have been to much work and would be suited as well. Although it might result in other problems with the generation of the platforms and their movement down the screen.

***Neverending Bounce*** One day was spend on exploring another approach to the whole movement of the avatar. This movement would make it possible for the avatar to move through the bottom of the platforms, while landing on the top of them as well. This approach would make the game considerably easier and would make the placement of the platforms (in relative space to and from each other) less essential. This only worked if the player's upward movement was registered as a conditional to the contact of the playerCategory and the platformCategory (which resulted in the repositioning of the player's baseline, thus letting the avatar register the platform as its new ground to stay on). However, this approach was explored as the avatar was using the gravity from the physicsbody and was using an impulse to simulate its jump. Therefore, the impulse had to be changed or registered every frame. Eventually we failed to do so and tested another way to control the movement up and down continuously by substracting -1 from its velocity. Going upwards it would subtract one until it would have reached zero (making the avatar stop in mid-air) and going down it would keep subtracting until it would meet a platform which would give it a positive velocity again. This way a negative velocity and contact with a platform could result in the player staying on the platform and a positive velocity would not register the platform as tangible. 
However, by using this substraction in every frame the avatar was forced to go either up or down, but not stop doing so. This way the movement of the avatar had become an neverending bounce which was a bit hard to control. The jump function leaned on the position of the avatar being set on a 'baseline', which it now only found when the avatar was hitting the ground of a platform. To make the game more controlled, a whole other way of movement had to be thought of. Contemplating these options, we decided that changing the movement of the avatar was going to require too much time and would change the game in a way that was not planned (risking a lot of unforeseen work). Therefore the neverending bounce was removed and the avatar now still bumps into the platforms any way it comes from. 

####Small but important as well:

#####the Moving Level... that isn't moving that much
At the start of the project, it seemed a good idea to make a separate class for the background. The background was 'divided' into segments of two colors alternating each other, so the movement could be registered before attaching any other nodes onto it.
Yet with the making of the platformgenerator class, it wouldn't have been that logical to attach the platforms from the platformgenerator to a node in another class entirely (with its own movement). Therefore the backgroundNodeTest was created to experiment with the idea of a clear node that has all the platforms attached to it as node-childeren. There were other plans for the Moving Level class like making the background render clouds that continuously kept moving over the screen. These were all supplementary features though, that would only be implemented if there was an abundance of time left (which there clearly was not).

#####The update function
At the start of the project I didn't know anything about SpriteKit, Scenes and SpriteNodes or how to work with them. I must admit I had a bit of knowledge about game-cycles and the way they updated the screen to make repeatedly drawn figures look animated. However, I didn't realize that the update function in XCode rendered per frame and not per second or the full completion of an SKAction. This way, the first SKActions were placed in the update function, but were called upon repeatedly before they were finished. This resulted in the animations speeding up madly from the start of the game. Fortunately this was quickly resolved in putting the SKActions outside of the update function and more importantly, have them followed up by a WaitForDuration method and setting them to execute uninterrupted until their own completion.


***

Limitations and obstacles
------------------------
##### Removing the 

Make sure the document is complete and reflects the final state of the application. The document will be an important part of your grade.

